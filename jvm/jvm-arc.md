JVMはどのように動くのか
-----

http://gihyo.jp/dev/serial/01/jvm-arc

## 第1回　JVMはどのようにメモリ空間を利用するのか

http://gihyo.jp/dev/serial/01/jvm-arc/0001
* JVMはメモリ空間を分けて使用する
    * Javaヒープ
        * Javaのプログラム内で使用されるメモリ空間
        * 建物のイメージ。JVMの種類や選択したGCの種類で変わるJavaヒープ
    * Cヒープ
        * JVMがネイティブライブラリで使用するメモリ空間
        * 庭のイメージ。Javaヒープ以外で使われるメモリ空間
    * スレッドスタック
        * JVMが持つスレッドの情報を格納。スレッドはGCやファイナライザを実行
        * 同じく庭のイメージ
* ヒープの空き容量を超えるサイズのオブジェクトを生成するとOOMになる


## 第2回　ヒープが再利用される仕組みを理解する

http://gihyo.jp/dev/serial/01/jvm-arc/0002

* ガベージコレクタは、不要なオブジェクトを回収してヒープを開放する仕組み
* 参照がないオブジェクトが対象になる
* JVMが必要なタイミングで実行
* 参照が残ってGCの対象とならないオブジェクトが増え続ける状態がメモリリーク
* GCで回収される前に処理を行いたい場合にはファイナライザを使う。時間がかかる処理を書くとGCに追いつけないので注意


## 第3回　システムトラブルの原因はGCの実装を知れば見えてくる

http://gihyo.jp/dev/serial/01/jvm-arc/0003

* システムが無反応になってしまう原因
    * CPUなどのリソース不足
    * コネクションやスレッドプール不足。待ち状態
    * GC設定の誤り
* 3の対策のために、GCの実行頻度や停止時間を考えなければならない
* 回収対象でないオブジェクトの量とヒープサイズを検討する必要がある
* STW(Stop The World)は、GCによってアプリケーションが止まる時間
* 停止に対するアプローチとして、スループットの向上もしくはレスポンスタイムの短縮のどちらを重視するか
    * スループット向上
→どこかのタイミングでまとめて停止させる
    * レスポンスタイムの短縮
→細かく停止させる


## 第4回　3つのGCを使い分けて停止時間を最小にする

http://gihyo.jp/dev/serial/01/jvm-arc/0004

* 3つのGC。シリアルGC、パラレルGC、コンカレントGC
* シリアルGC
    * すべてのアプリケーションスレッドを停止し、1つのスレッドでGCを実行する
    * アプリケーションの停止時間が長くなってしまう
* パラレルGC
    * すべてのアプリケーションスレッドを停止し、複数のスレッドでGCを実行する
    * シリアルGCと比較して停止時間が短くなる
    * GCスレッド間の同期にオーバーヘッドがある
* コンカレントGC
    * アプリケーションスレッドと同時にGCスレッドを動作
    * 停止時間なくGCを行うことができる
    * GCスレッド間の同期にオーバーヘッドがあるが停止時間は短縮する
    * すべてのフェーズがコンカレントで処理できるわけではないため、完全に停止時間をゼロにはできない

## 第5回　チューニングのために理解しておきたいGCの4つのアルゴリズム

http://gihyo.jp/dev/serial/01/jvm-arc/0005

* GCチューニングの流れは、モニタリング→分析→チューニング
* 4つのアルゴリズム。マークスイープGC、コンパクション、コピーGC、世代別GC
* マークスイープGC
    * 2つのフェーズに分けて実行
    * マークフェーズ
        * 生きているオブジェクトをマーク
    * スイープフェーズ
        * マークされていないオブジェクトを削除
    * 空き領域が断片化してしまう
* コンパクション
    * バラバラに配置されたオブジェクトを連続して配置。空き領域の場所を見つけやすくする
* コピーGC
    * GCとコンパクションを同時に行う
    * From領域とTo領域に分ける。新しいオブジェクトはFrom領域に作られ、生きているオブジェクトをコピーGCがTo領域にコピーする。その後、To領域がFrom領域として使われるようになる。これによって断片化を防ぐ
    * From領域しか使えないため、使える容量が半分になる問題がある
* 世代別GC
    * 使われる時間でオブジェクトを分けて管理、GCする
    * 全てのオブジェクトをGC対象とすることを一世代ヒープと呼ぶ
    * オブジェクトがGCされた回数を年齢(age)と呼び、年齢が若い領域をYoung領域、古い領域をOld領域と呼ぶ
    * それぞれの世代で管理するのでGCの実行時間が減る。古い世代はなかなかGCされない
