Java
==

# 修飾子

* transient
    * 指定したフィールドをシリアライズの対象から除外
    * シリアライズは、オブジェクトをバイト列に変換すること。オブジェクトをファイルやDBに保存したりネットワークで送受信するときに使う。staticなフィールドのシリアライズの対象外
* volatile
    * マルチスレッドからアクセスされるフィールドに対して、スレッド毎に値がキャッシュされないように指定
* synchronized
    * マルチスレッドで同時に1つのスレッドからしかアクセスされないことを保証

# プリミティブ型とラッパークラス(参照型)

* プリミティブ型の初期値は0, ラッパークラスの初期値はnull
* 数値計算に利用する変数はプリミティブ型を使う
* ファイルやデータベース、HTTPリクエストなどを保持する場合はラッパークラスを使う
* オートボクシングやアンボクシングは原則利用せず、明示的な変換を行う。記述量の削減が有効の場合にだけ使う
    * プリミティブ型からラッパークラスへの自動変換をオートボクシングと呼ぶ

# オブジェクトの等価性

* オブジェクトが等価であると判定するには以下を満たす必要がある
    * オブジェクトのhashCodeメソッドの値が一致
    * equalsで等価
* equalsは値の比較、hashCodeはオブジェクトのハッシュ値による比較
* hashCodeのハッシュは異なるオブジェクトでもハッシュ値が同じになることがあるため、hashCodeでオブジェウトを比較した後equalsで厳密な判定を行う必要がある

# ジェネリクス

* 汎用的な処理を記述する際に利用される型。<>のダイヤモンドオペレータを使う
* Listなどで特定のオブジェクトしか追加できない、値を取り出すときにキャストが不要になる
* クラスを作成するには仮想パラメータを用いてパラメータ化された型として定義する

# 配列

* Arrays.toStringで配列の要素一覧を文字列で確認できる
* 配列ではほとんどComparatorを使う、Comparableを利用することはあまりない
* 配列は一度作成してしまうと要素を変更できない。要素数を変更したい場合は、新しい配列を作成した上で古い配列をそこにコピーする

# List

* indexOfメソッドは、引数で指定した値と一致する要素のインデックスを取得する。先頭から最初に見つかった要素のインデックスを返す
* ArrayList
    * インスタンスを作るときは、長さを指定しないと内部で長さ10の配列が作られる
    * 配列のサイズ以上の要素を追加しようとした際には、新たに配列を作って元の配列をコピー、が実行されるため、可能であればコンストラクタで初期値を指定したほうが良い
    * インデックスを指定して要素を追加削除するのは高速。内部に配列を持っているため
    * リストの途中に要素を追加するときは、それ移行の要素をすべて1つずつ後ろにずらさなければいけないので時間がかかってしまう
* LinkedList
    * 要素自身が前後の要素のリンクをもっているため、ArrayListのような初期サイズの概念はない
    * 途中の要素の追加は高速。前後の要素のリンクを変更するだけのため
    * インデックスを指定して要素の追加は時間がかかる。先頭から順番にリストをたどる必要があるため
* CopyOnWriteArrayList
    * ArrayListをスレッドセーフ化したクラス
* 使い分け
    * 配列の途中で要素の追加や削除を行うことが多い場合は、LinkedList
    * for文などを使った全体的な繰り返し処理が多い場合は、ArrayList
    * 複数スレッドから同時にアクセスする場合は、CopyOnWriteArrayList

# Map

* HashMap
    * ハッシュテーブルでキーと値を持つ
    * キーはhashCodeメソッドの結果をハッシュテーブルのサイズで割ったときの余りがインデックスになる
    * 要素を追加する際にハッシュテーブルのサイズを拡張する処理と要素の追加処理が同時に行われると、無限ループになる可能性があるため、複数スレッドから扱うときには注意が必要
* LinkedHashMap
    * 要素が前後の情報を持っているHashMap
* TreeMap
    * 二分探索で要素をソートするクラス
    * ソートされた状態で保持される
    * 追加・削除・検索はO(logn)の計算量になる
* 使い分け
    * キーの大小を意識した部分集合を取り扱う場合は、TreeMap
    * 要素の順序を保持する必要がある場合は、LinkedHashMap
    * 複数スレッドから同時にアクセスする場合は、ConcurrentHashMap
    * その他の場合は、HashMap

# Set

* Setの内部にはMapが存在し、Setに追加された要素はMapのキーとして保持される。値にはObject型のインスタンスが格納されるがこれが使われることはない
